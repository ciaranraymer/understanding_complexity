import pint
import scipy as sp
import numpy as np
import matplotlib as mp
import matplotlib.pyplot as plt
UNITS = pint.UnitRegistry()
Quantity = UNITS.Quantity
 
 #Driver characteristics
class Driver:
     def __init__(self, loc, speed, acceleration, safety_dist, sensitivity, reaction_time):
         self.start = loc
         self.loc = loc
         self.speed = v_max
         v_max = V * (metre / second)
         self.acceleration = acc * (metre / second)**2
         self.safety_dist = s
         s = 2
         self.sentivity = a
         a = 1
         self.reaction_time = rt
         dx = ((self.loc+1)-self.loc)
 
#Road characteristics
class Road:
         def __init__(self, n, radius, length, agent=Driver):
             self.length = length * metre
             length = 200
             self.n = cars
             cars = 100
             self.radius = r
             r = (length / (2 * pi))
     
             locs = np.linspace(0, length, n, endpoint=False)  #links the Road and Driver classes
             self.drivers = [agent(loc) for loc in locs]
             for i in range(n):
                 j = (i+1) % n
                 self.drivers[i].next = self.drivers[j]
 
 #create movement of drivers along the road
def move(self, driver):
     d = self.distance(driver)
     speed = driver.speed + acc
     if speed > d:
         speed = 0
     driver.speed = speed
     driver.loc += speed                
     
 #OVF from Sugiyama (1999)
optimal_velocity_function = np.tanh(dx-2) + np.tanh(2)
 
 #Euler method to return new position of drivers
def euler_method(x, v, n, h, tau, s, v_max):
     dv = np.zeros(n)
     for j in range(n - 1):
         dv[j] = tau ** (-1) * (optimal_velocity_function(x[j+1] - x[j], s, v_max) - v[j])
     dv[n - 1] = tau ** (-1) * (v_max - v[n - 1])
     v_new = v + h * dv
     x_new = x + h * v_new
     return [x_new, v_new]
